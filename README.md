# simple_grammar
This is the grammar for the Simple programming language. It is a simplified representation of a BNF grammar using regular expressions. This format is optimized for use with a simple python script that is used to generate the boilerplate code for a parser.

The purpose of the parser that this code boilerplate is made for is to create the Abstract Syntax Table (AST) from the input. To that end, the files and functions for the parser and for the AST are generated at the same time, but in separate directories. Templates are made for function calls as well as data structures. The parser is then generated by hand.

## Grammar structure
The grammar file is structured into rules as shown below. Provision for comments are made so that a comment starts with a ``#`` character and ends at the end of the line. Comments can only appear outside of a rule definition.

## Rule structure
Rules are structured as they would be in a YACC grammar, except that there is no code defined for a match and the regular expressions are used as above.

Example:

```
# this is a comment
non_terminal_rule_name ( expression_rule )

non-term {
  rule_option_1 |
  rule_option_2
}
```

A rule consists of a combination or terminal and non-terminal symbols that can be nested as indicated.

## Regular expressions
These simple regular expressions are used to specify loops and optional items. No "regular expression" library is being used.

* ``( item )?`` represents a single optional item
* ``( item )*`` represents an optional list of items
* ``( item )+`` represents a list of one or more items
* ``( item | item )`` represents two alternative items

An item can be any construct. For example ``( item ( ',' ( item_1 | item_2 )  )* )+`` represents one required ``item`` followed by zero or more things that are a ``','`` followed by an ``item_1`` or an ``item_2``.

All regular expressions are enclosed in parentheses.

## Symbol types
There are 2 categories of symbol in the file. They are non-terminal and terminal.

* A non-terminal symbol is one that defines a sequence of other symbols. These symbols can be another non-terminal or it could be a terminal symbol. All non-terminals are defined as the beginning of a rule.
* A terminal symbol is one that defines an object that was actually read from source code by the scanner.
	* A terminal that is defined using single quotes is an absolute literal. A terminal defined with double quotes is not case-sensitive. For example a non-terminal defined as `` 'while' `` only matches the string ``while``, whereas the non-terminal defined as ``"while"`` matches the strings ``while, While, and WHILE``, as well as any other combination of upper and lower case. The token will be referred to as ``WHILE_TOKEN`` in the scanner and the generated parser.
	* A terminal symbol that is defined as all upper case defines a literal token that is constructed by the scanner, such as numbers and identifiers. When the boilerplate is processed, these symbols are treated as if they must be stored in the AST data structure. The string ``_TOKEN`` will be appended to the name that was read from the grammar.
	* Terminal symbols that are special characters, such as ``'(' and '*'`` are changed to make them acceptable token names. For example the string ``'>='`` translates to the token name ``GREATER_EQUAL_TOKEN`` in the output.

## Output
The output of this functionality is a parser and AST for the grammar. These are not functional as they are output but they should build as-is. All headers and other infrastructure is output such that the compiler will not complain.

Two directories are created; they are ``ast`` and ``parser`` to contain the respective outputs. Running this program rebuilds the entire output without warning. A separate file is created for every non-terminal symbol and the parser files have the code to parse the non-terminal and the AST contains the code to traverse the resulting AST.
